/***********************************************************************
 * Module:		DiskDll.dll
 * FileName：	disktool.h 
 * Author:		杨松
 * Modified:	2012年5月12日 星期六 
 * Purpose:		声明磁盘，FAT32，NTFS以及相关文件的操作的方法
 * Comment:		本模块主要是封装了磁盘、FAT32卷、FAT32文件、NTFS卷和NTFS
 *				文件的操作。
 *				在本库中使用了的windows API有，CreateFile，ReadFile，WriteFile
 *				SetFilePointer,DeviceIoControl,CloseHandle,
 *
 *
 *				本文件则主要是定义了一下要导出的类，以及一些依赖的数据结
 *				构、数据类型，常用宏等
 ***********************************************************************/
/*
#ifdef DISKTOOL_EXPORTS
#define DTOOL_API __declspec(dllexport)
#else
#define DTOOL_API __declspec(dllimport)
#endif
*/

#define  DTOOL_API

#ifndef  _DISK_TOOL_H_
#define  _DISK_TOOL_H_

#ifdef _DEBUG
//#include <vld.h>
#endif

//因为要导出类，所以有必要保证到处前后的内存对齐方式一致
#pragma pack(push  , 8 )

#ifndef _MSC_VER  //不是vc编译器
//////////////////////////////////////////////////////////////////////////
//一些常用的基本的数据类型
//一般也是和windows保持一致的
//////////////////////////////////////////////////////////////////////////

typedef unsigned short		WCHAR;//在vc6.0中将WCHAR定义为unsigned short，但是在vs2008或者跟高的版本中则要定义为wchar_t
typedef int					INT;
typedef unsigned short		WORD;
typedef unsigned long		ULONG;
typedef unsigned long		DWORD;
typedef __int64             LONGLONG;
typedef unsigned long*		PDWORD;
typedef unsigned short		USHORT;
typedef unsigned char		UCHAR;
typedef void*				PVOID;
typedef void				VOID;
typedef int					BOOL;
typedef unsigned char		BYTE;
#define TRUE				1
#define FALSE				0

#else  //是vc编译器

#include "windows.h"

#endif // _MSC_VER

#include <vector>
#include <memory>

typedef int					DRES;    //操作结构类型

//在此文件中申明的类
class Disk;
class DFat32;
class DFat32File;
class DNtfs;
class DNtfsFile;
class DList;


//////////////////////////////////////////////////////////////////////////
//用于表示64位数据的数据类型
//////////////////////////////////////////////////////////////////////////
typedef union _tagLONG_INT{
	struct {
		unsigned long LowPart;
		long          HighPart;
	};
	__int64 QuadPart;

	_tagLONG_INT(long v = 0) : QuadPart(v){}
} LONG_INT , *PLONG_INT;


//句柄的声明
#ifndef DECLARE_HANDLE
#define DECLARE_HANDLE(name) struct name##__ { int unused; }; typedef struct name##__ *name
#endif

#ifndef HANDLE
typedef void*  HANDLE;
#endif

//一个用于文件查找的句柄
#ifndef FINDER
DECLARE_HANDLE(FINDER);
#endif


/*////////////////////////////////////////////////////////////////////////*/
#define	DR_OK				0x00	//操作成功
#define DR_NO				0x01	//操作的否定
#define	DR_INVALED_PARAM	0x02	//参数错误
#define	DR_OPEN_DEV_ERR		0x03	//打开设备失败 可已经检查设备的名字是否设置正确
#define	DR_DEV_CTRL_ERR		0x04	//设备控制出错 如移动读写指针
#define	DR_DEV_IO_ERR		0x05	//设备IO出错 如读写操作
#define	DR_INIT_ERR			0x06	//设备(文件等)初始化错误  如读取到错误的数据,或者是参数的内容错误（指针参数）
#define	DR_INVALID_NAME		0x07	//路径名不合法
#define	DR_NO_FILE			0x08	//没有找到指定的文件
#define DR_NO_PATH			0x09	//没有指定的路径
#define DR_IS_DIR			0x0A	//是目录
#define DR_IS_FILE			0x0B	//是文件
#define DR_FAT_EOF			0x0C	//簇链的结尾,获得属性链的末尾了,获得ntfs文件查找完了,FAT32文件查找到了结尾
#define DR_INVALID_HANDLE	0x0D	//错误的句柄
#define DR_ALREADY_OPENDED  0x0E	//已经打开，或者已经存在，如设备已经打开，ntfs属性已经初始化
#define DR_NO_FILE_NAME		0x0F	//没有文件名,如ntfs的文件，没有文件名属性
#define DR_INNER_ERR		0x10	//内部错误哦
#define DR_BUF_OVER			0x11	//缓存区不够
#define DR_NO_FILE_DATA		0x12	//文件没有数据属性，可能是系统文件(NTFS)
#define DR_NO_OPEN			0x13	//当前设备或者文件根本就没有打开,或者是打开时出错了


/*////常用的宏函数/////////////////////////////////////////////////////////*/
//判断dpt表象只向的是否是一个扩展分区
#define  IsExtPart(pdpt)  ((0x5 == (pdpt)->mPartType ||\
							0xF == (pdpt)->mPartType )&& \
							(0x8 == (pdpt)->mGuidFlag || \
							0x00 == (pdpt)->mGuidFlag))
//是不是FAT32的分区
#define	IsFAT32fs(x)	((x == 0x01) || \
						 (x == 0x0B) || \
						 (x == 0x0C) || \
						 (x == 0x1B) || \
						 (x == 0x1C))
#define IsNTFSfs(x)		(((x) == 0x7) || ((x) == 0x17))
//判断一个字符是不是路径分割符
#define	IsPathSeparator(x)	(((x) == '\\') || ((x) == '/') )
#define PATH_SEPAR			'/'			//默认使用的分割符		

//FAT32表项的一些操作
#define FAT_MASK		0x0FFFFFFF		//FAT32表项有效掩码
#define	FAT_FREE		0x00000000		//FAT32空闲簇表项
#define FAT_BAD			0x0FFFFFF7		//FAT32坏簇表项
#define FAT_END			0x0FFFFFF8		//FAT32簇链的结尾了

#define IsFATFree(x)	((x & FAT_MASK) == FAT_FREE)  //是否为空闲表项
#define IsFATBad(x)		((x & FAT_MASK) == FAT_BAD)	//是否为空闲表项
#define IsFATEnd(x)		((x & FAT_MASK) >= FAT_END)	//粗炼的结尾了

//获得指针的处的制定类型数据
#define GetLONG_INT(x)	(*((LONG_INT*)((BYTE*)(x))))
#define GetDWORD(x)		(*((DWORD*)((BYTE*)(x))))
#define GetWORD(x)		(*((WORD*)((BYTE*)(x))))
#define GetBYTE(x)		(*((BYTE*)(x)))

//在指针出写入制定类型数据
#define SetLONG_INT(p , v)	(*((LONG_INT*)((BYTE*)(p))) = (LONG_INT)(v))
#define SetDWORD(p , v)		(*((DWORD*)((BYTE*)(p))) = (DWORD)(v))
#define SetWORD(p , v)		(*((WORD*)((BYTE*)(p))) = (WORD)(v))
#define SetBYTE(p , v)		(*((BYTE*)(p)) = (BYTE)(v))



//文件属性
//FAT32目录项的属性
#define ATTR_READ_ONLY		0x01		//只读文件			00000001
#define	ATTR_HIDDEN			0x02		//隐藏文件			00000010
#define	ATTR_SYSTEM 		0x04		//系统文件			00000100
#define	ATTR_VOLUME_ID 		0x08		//卷标				00001000
#define	ATTR_DIRECTORY		0x10		//子目录			00010000  //我柑橘有些ntfs文件没有此属性
#define	ATTR_ARCHIVE		0x20		//归档				00100000
#define	ATTR_LONG_NAME		0x0F		//长命入口			00001111

//一下只有ntfs文件有的属性
#define ATTR_DEVICE			0x0040		//设备文件			01000000            
#define ATTR_NORMAL			0x0080		//Normal			10000000
#define ATTR_TEMPORARY		0x0100		//临时文件		   100000000
#define ATTR_SPARES			0x0200		//稀疏文件		  1000000000
#define ATTR_REPARSE_POINT	0x0400		//Reparse Point	 10000000000
#define ATTR_COMPRESSED		0x0800		//压缩文件      100000000000  压缩和加密不能同时存在
#define ATTR_OFFLINE		0x1000		//Offline      1000000000000 
#define ATTR_NOT_CONTENT_IDX 0x2000//没有索引的index  10000000000000
#define ATTR_ENCRYPTED		0x4000		//加密	     100000000000000
#define ATTR_DIRECTORY_INDEX 0x10000000	//ntfs目录
#define ATTR_INDEX_VIEW		 0x20000000	//Index View

#define ATTR_NTFS_MASK		0x30007FE7	//NTFS文件属性掩码  110000000000000111111111100111
#define ATTR_FAT32_MASK		0x3F		//FAT32掩码		 0000000000111111


//////////////////////////////////////////////////////////////////////////
//FAT32的第0C（目录项数据结构中的mNameCase）字节的含义，具体是否是如下不得
//而知，这只是我自己的不完全统计的结果。
//在FAT32中短文件名、扩展名都是以大写字符的形式展示的，但是有些情况确实有
//小写的情况,也就是说我创建的文件（符合8.3规则）确实存在小写字符。所以如下:
//
//文件名小写	00001000
//扩展名小写	00010000
//两者可以相与('|'),也就是说如果文件名为小写的话，则0C字节的第3位为1。如果扩
//展名为小写的话，则0C字节第4位为1.综上：
//文件名小写，扩展名小写,如aaa.aaa	则00011000=18h
//文件名大写，扩展名大写,如AAA.AAA	则00000000=00h
//文件名大写，扩展名小写,如AAA.aaa	则00010000=10h
//文件名小写，扩展名大写,如aaa.AAA	则00001000=08h
//
//在这里长文件名目录项（或者与之对应的短文名目录项）我没有管（根本不需要理
//会），而且仿佛都是0
//////////////////////////////////////////////////////////////////////////
#define FNAME_LOWER_CASE		0x08
#define FEXT_NAME_LOWER_CASE	0x10



/*/一些常量的定义///////////////////////////////////////////////////////////////////////*/
#define DISK_PRE_NAME	L"\\\\.\\PhysicalDrive"	//磁盘设备名字的前缀
#define EXT_DPT_FLAG	0x705A5A5A5A			//扩展分区表的起始标记

//车老板说windows最多可以挂载0x80个物理磁盘
//但是我在一个国外的源程序(dskwipe)中看到他是以0x40为上限的
#define MAX_DISK_COUNT	0x80				//系统可以挂载的最大的磁盘数量

#define DEVICE_NAME_LEN 21					//设备的名字长度
#define	SECTOR_SIZE		512					//扇区的字节大小
#define MAX_PATH		260					//最大的路径长度
#define MAX_LFN			255					//最大的长文件名长度
#define MAX_NTFS_VOLUME_NAME_LEN	127		//NTfs卷名的最多字符数

#define  MBR_END		0xAA55				//个工作数据山区的结束标记

//磁盘的区域类型
#define  PART_MBR		0x100			//MBR
#define  PART_EBR		0x101			//EBR
#define  PART_UN_PART	0x102			//没分区的空闲区域
#define  PART_UNPARTBLE 0x103			//不能分区的区域
#define	 PART_FAT32		0x0C			//FAT32  
#define  PART_NTFS		0x07			//NTFS

//判断一个区域是否为一个文件系统
#define  IsPartFS(x) ((x) != PART_MBR && (x) != PART_EBR && (x) != PART_UN_PART && (x) != PART_UNPARTBLE)


//AttrDef  的取值  NTFS
#define	AD_STANDARD_INFORMATION		0x10
#define AD_ATTRIBUTE_LIST			0x20
#define AD_FILE_NAME				0x30
#define AD_VOLUME_VERSION			0x40 //NT	
#define AD_OBJECT_ID				0x40 //2K
#define AD_SECURITY_DESCRIPTOR		0x50
#define AD_VOLUME_NAME				0x60
#define AD_VOLUME_INFORMATION		0x70
#define AD_DATA						0x80
#define AD_INDEX_ROOT				0x90
#define AD_INDEX_ALLOCATION			0xA0
#define AD_BITMAP					0xB0
#define AD_SYMBOL_LINK				0xC0 //NT
#define AD_REPARSE_POINT			0xC0//2K
#define AD_EA_INFORMATION			0xD0
#define AD_EA						0xE0
#define AD_PROPERTY_SET				0xF0//NT
#define AD_LOGGED_UNTILITY_STREAM	0x100//2K



//ntfs文件系统的文件名命名空间
#define  NS_POSIX		0
#define	 NS_WIN32		1
#define  NS_DOS			2
#define  NS_WIN32_DOS	3
#define  NS__ALL		4		//所有的文件名都可以

//移动文件的时候 的先对位置选项
#define FILE_POS_BEGIN		0		//文件的起始位置 
#define FILE_POS_CURRENT	1		//文件的当前位置 
#define FILE_POS_END		2		//文件的结束位置


//每条记录的所占用的扇区数
#define SECTOR_PER_RECODE		2
//MFT记录的的大小
#define MFT_RECODE_SIZE		(SECTOR_PER_RECODE * SECTOR_SIZE)

//NTFS中的系统保留文件的MFT记录号
#define SYS_FILE_MFT		0	// $MFT   MFT文件列表－每个文件的索引 
#define SYS_FILE_MFTMIRR	1	// $MFTMirr   MFT前4个记录的备份 
#define SYS_FILE_LOGFILE	2	// $LogFile   事务型日志文件 
#define SYS_FILE_VOLUME		3	// $Volume   序列号，开发时间，污染标记 
#define SYS_FILE_ATTRDEF	4	// $AttrDef   属性定义 
#define SYS_FILE_ROOT		5	// . (dot)   磁盘的根目录 
#define SYS_FILE_BITMAP		6	// $Bitmap   包含卷的簇图（在用和空闲） 
#define SYS_FILE_BOOT		7	// $Boot   卷的引导记录 
#define SYS_FILE_BADCLUS	8	// $BadClus   列出在卷上的坏簇 
//9 $Quota NT 限额信息 
#define SYS_FILE_SECURE		9	// $Secure 2K 卷所用的安全描述符 
#define SYS_FILE_UPCASE		10	// $UpCase   用于比较的大写字母表 
#define SYS_FILE_EXTEND		11	// $Extend 2K 一个目录：$ObjId, $Quota, $Reparse, $UsnJrnl 



//////////////////////////////////////////////////////////////////////////
//关于NTFS系统的时间戳的问题
//*NTFS文件系统的时间存储是以100ns（1s = 1,000,000,000 ns）为单位的，起始时
//*间是协调世界时(UTC)1601年1月1日00:00:00.000。
//*Unix Time 是以秒为单位的，其起始时间是(UTC)1970年1月1日00:00:00。
//*Unix Time 也是C函数time()返回的时间类型
//
//*在这两起始时间的之间相隔369年，其中有89个闰年（92个年号可以被4整除，但
//*是有3个可以被100整除）
//
//*下面是以上两个时间的秒数之差
//////////////////////////////////////////////////////////////////////////
#define NTFS_TIME_OFFSET ((LONGLONG)(369 * 365 + 89) * 24 * 60 * 60)



//////////////////////////////////////////////////////////////////////////
//对磁盘的操作的封装
//////////////////////////////////////////////////////////////////////////
class DTOOL_API Disk
{
public:
	Disk(void);
	~Disk(void);
	
	//////////////////////////////////////////////////////////////////////////
	//在这里定义了一个磁盘区域的表示方式，可以表示一个MBR。EBR。文件系统分区.
	//未分区的区域，或者无法分区的区域
	//////////////////////////////////////////////////////////////////////////
	typedef struct _tagDPART{
		LONG_INT	mOffset;        //本分区的物理偏移量,也就是本分前使用了的总扇区数
		DWORD		mRelativeSectors;//相对扇区数
		USHORT		mType;          //分区类型
		LONG_INT	mSecCount;		//此区域的扇区数量
		BOOL		mIsMainPart;	//是否为主分区,知否在当前节点值得是卷的时候有效
		BOOL		mIsActivity;	//是否为活动分区
		INT			mVolIndex;		//卷的索引，如果当前区域不是一个卷的话置为-1，否则
									//从0,1,2...。此值是按DPT链表遍历是计算出来的,不是物理位置的索引
		CHAR		mLogicalLetter;	//逻辑驱动的字符
	}DPart , *PDPart;
private:
	DList* mPPartList;		//此次盘的分区链表  该成员不得使用 
							//malloc 和 free系列函数  因为这样
							//不会他的构造函数 和 析构函数
	HANDLE			mDisk;			//一个已经打开的磁盘设备句柄
	LONG_INT		mPartableSecCnt;//磁盘的可分配扇区数
	LONG_INT		mExtPos;        //磁盘中扩展分区的其实位置(扇区)
	DWORD			mUnPartSize;	//不可分区字节数
	DWORD			mVolCnt;		//卷的总数
	DWORD			mMainVolCount;	//主分区数量
	BOOL			mIsGetUnPartSec;//已经获得了不可分配了的空间大小
	WCHAR			mDevName[DEVICE_NAME_LEN];		//设备名字 ,通过此属性判断设备是否打开
	DWORD			mSecPerTrack;//每磁道扇区数
	DWORD			mTracksPerCylinder;//每柱面磁道数
	LONG_INT		mCylinders;		//柱面数
private:
	//////////////////////////////////////////////////////////////////////////
	//分析指定DPT的数据   将获得分区添加到分区链表中去
	//param       
	//		hDisk           设备句柄
	//		dpt             当前要分析的DPT表项
	//		dptoff			dpt所在的EBR的偏移
	//		isFirstDPT      指定的DPT表项是否属于磁盘的第一个PDT
	//return 
	//		TRUE    操作成功
	//		FALSE   操作失败,读取数据失败
	//////////////////////////////////////////////////////////////////////////
	BOOL ListPartion(
/*		HANDLE        hDisk,			//*/
		PVOID         dpt,				//当前要列举分区信息
		LONG_INT	  dptoff,			//
		BOOL          isFirstDPT,		//是否是第一个DPT
		DWORD*		  pLogicDir);		//逻辑驱动表
	
	//////////////////////////////////////////////////////////////////////////
	//读取指定的区域的数据
	//param 
	//		hDisk   要读取数据的设备句柄
	//		offert  读取数据的位置(扇区)
	//		buf     要读取数据的缓存
	//		dwReaded 读取到的数据长度
	//		buflen  要读的数据大小
	//return       
	//		TRUE    获取成功
	//		FALSE   获取失败。失败原因可能是mbr的数据没有分配,或者hDisk 参数有
	//				问题,或者起始偏移不正确
	//////////////////////////////////////////////////////////////////////////
	BOOL ReadSecter(/*HANDLE hDisk ,*/LONG_INT offert , PVOID buf  ,DWORD* dwReaded ,DWORD buflen = SECTOR_SIZE);

	//////////////////////////////////////////////////////////////////////////
	//加载磁盘的分区列表
	//param 
	//		hDisk   打开的磁盘设备句柄
	//return       
	//		TRUE    获取成功
	//		FALSE   获取失败
	//				已经加载了列表,或者hDisk 参数有问题,读取MBR失败,起始偏移不正确
	//////////////////////////////////////////////////////////////////////////
	BOOL LoadPartList(/*HANDLE hDisk*/);
	
	//////////////////////////////////////////////////////////////////////////
	//使链表连续，计算磁盘的有效不可分配的空间的大小
	//param
	//		hDisk		打开的磁盘句柄
	//return       
	//		连续成功	TRUE
	//////////////////////////////////////////////////////////////////////////
	BOOL MakeListContinue(/*HANDLE hDisk*/);

	//////////////////////////////////////////////////////////////////////////
	//根据实际情况创建一个分区节点  如DFAT32 NTFS 的节点
	//param
	//		dpt			要分析的DPT表项    如果此域NULL 类型有type决定
	//		off			分区的实际物理偏移
	//		type		分区的类型       dpt不为NULL此域忽略
	//		isMainPart	是否为分区,此域只有在当前节点指卷的情况下有效
	//		pLogicDri	当前设备的逻辑驱动表,如果不是文件系统的话可能为NULL
	//return 
	//		NULL	创建失败  可能是参数错误
	//////////////////////////////////////////////////////////////////////////
	PVOID NewPart(PVOID dpt, PLONG_INT off, int type , BOOL isMainPart = FALSE , DWORD* pLogicDri = NULL);

	//////////////////////////////////////////////////////////////////////////
	//比较两个节点的其实位置大小
	//param
	//		p1    带比较的节点指针1
	//		p2    带比较的节点指针2
	//return 
	//		TRUE	p1 < p2
	//////////////////////////////////////////////////////////////////////////
	static BOOL ComparePart(VOID* p1, VOID* p2);


	//////////////////////////////////////////////////////////////////////////
	//获得当前物理设备所对应逻辑驱动器盘符
	//return	res	逻辑驱动器在此设备上的位置序列
	//			如果返回res==NULL的话获取数据失败
	//			成功的话res[0]在此设备上的文件系统数量,res[1],res[2]..都是LOGCDRI
	//			使用完了的话需要delete[]
	//////////////////////////////////////////////////////////////////////////
	DWORD* GetLogicalDrives();

public:

	//////////////////////////////////////////////////////////////////////////
	//获得磁盘的扇区总数，如果没有获取不可分配的扇区数时，返回的是可分配的扇区
	//数
	//如果设备还没有打开的话，返回-1
	//////////////////////////////////////////////////////////////////////////
	LONG_INT GetSecCount();
	
	//////////////////////////////////////////////////////////////////////////
	//获得磁盘可以分配的空间扇区数
	//如果设备还没有打开的话，返回-1
	//////////////////////////////////////////////////////////////////////////
	LONG_INT GetPartableSecCount();

	//////////////////////////////////////////////////////////////////////////
	//获得不可分区大小字节数
	//如果还没有打开设备的话，返回0
	//////////////////////////////////////////////////////////////////////////
	DWORD GetUnPartableSize();

	//////////////////////////////////////////////////////////////////////////
	//获得磁盘的不可分配的空间扇区数,这个方法比较耗时，建议不要再用户线程中使用。
	//我是读取扇区的方法来判断是次扇区是否有效，如果有效的话执行还比较快，但是
	//如果扇区无效的话，估计要耗时几秒，我用折半查找的方式测试了一下，执行玩这
	//个函数估计要1分钟，后来换为了了穷举法，也要几秒，这是IO问题，其他的都没问
	//题，只是在读取到了一个不存在的扇区数要比较久的时间
	//
	//param
	//		secCount	不可分配空间的扇区数，如果此域为NULL的话只是触发获取不可分
	//					的大小,将数据存储在链表里，而不会返回这个值
	//return       
	//		操作成功	TRUE
	//		操作失败	FALSE
	//////////////////////////////////////////////////////////////////////////
/*	BOOL GetUnPartSecCount(DWORD * secCount = 0);*/

	
// 	//////////////////////////////////////////////////////////////////////////
// 	//获得不可以分配的空间山区数
// 	//如果没有的不可分配的空间或者还没有查找的话返回0
// 	//////////////////////////////////////////////////////////////////////////
// 	DWORD GetUnPartableSecCount();

	//////////////////////////////////////////////////////////////////////////
	//获得物理存储设备的数量，注意，物理磁盘的名字不一定是以0~n顺序编号的，可能
	//是0.2.4等
	//return       
	//		0……n  设备的数量
	//////////////////////////////////////////////////////////////////////////
	static int GetDiskCount(void);

	//////////////////////////////////////////////////////////////////////////
	//通过磁盘的索引 打开一个物理磁盘
	//param 
	//		index   物理磁盘的索引   (0...n)
	//return       
	//		TRUE    打开成功
	//		FALSE   打开失败
	//			失败的原因可能是 已经打开一了一个磁盘，但还没关闭，又继续打开
	//			或者也可能是索引不正确,或者打开设备失败
	//////////////////////////////////////////////////////////////////////////
	BOOL OpenDisk(int index);

	//////////////////////////////////////////////////////////////////////////
	//通过磁盘的索引名字 打开一个物理磁盘  这里只能用于打开磁盘 而不是卷
	//param 
	//		name   物理设备的名字
	//return       
	//		TRUE    打开成功
	//		FALSE   打开失败
	//			失败的原因可能是 已经打开一了一个磁盘，但还没关闭，又继续打开
	//			或者也可能是名字不正确
	//////////////////////////////////////////////////////////////////////////
	BOOL OpenDisk(const WCHAR* name);
	
	//////////////////////////////////////////////////////////////////////////
	//关闭当前打开的磁盘  在这里只是释放磁盘的分区链表的数据等一些数据的清理
	//////////////////////////////////////////////////////////////////////////
	void CloseDisk(void);

	//////////////////////////////////////////////////////////////////////////
	//判断当前设备是否已经正确打开
	//////////////////////////////////////////////////////////////////////////
	inline BOOL IsDiskOpened() { return ((wcslen(mDevName) != 0) && (mDisk != INVALID_HANDLE_VALUE) && (mDisk != NULL)); }

	//////////////////////////////////////////////////////////////////////////
	//获得当前磁盘的分区数量,不是逻辑驱动数，被划分区域数
	//return   
	//		当前分区的数量  (没有返回0)
	//////////////////////////////////////////////////////////////////////////
	int GetPartCount(void);

	//////////////////////////////////////////////////////////////////////////
	//获得当前磁盘的卷的总数
	//return
	//		卷总数，如果磁盘还没有打开的话返回0
	//////////////////////////////////////////////////////////////////////////
	DWORD GetVolumeCount();

	//////////////////////////////////////////////////////////////////////////
	//获得主分区数量
	//return
	//		当前磁盘的主分区数量，如果磁盘还没有打开的话返回0
	//////////////////////////////////////////////////////////////////////////
	DWORD GetMainVolCount();
	
	//////////////////////////////////////////////////////////////////////////
	//		一下是获得磁盘中的各个区域的信息
	//////////////////////////////////////////////////////////////////////////
	//获得指定区域(卷，MBR，EBR等)
	//param
	//		index		指定分区的节点序号,最大是GetPartCount()-1
	//return
	//		如果返回NULL的话表示索引越界
	//////////////////////////////////////////////////////////////////////////
	const PDPart GetPart(int index);

	//////////////////////////////////////////////////////////////////////////
	//获得指定的逻辑驱动的卷
	//param
	//		letter	罗驱动盘符
	//return
	//		如果指定设备不存在的话返回 NULL，否则相应的逻辑驱动
	//////////////////////////////////////////////////////////////////////////
	const PDPart GetPart(char letter);
	
	//////////////////////////////////////////////////////////////////////////
	//获得指定区域节点的区域类型,详细情况请看strut_conf.h 文件尾
	//param
	//		index		指定分区的节点序号,最大是GetPartCount()-1
	//return
	//		分会区域的分区类型  详细情况请看strut_conf.h的末尾
	//		如果index无效则返回0xFFFF
	//////////////////////////////////////////////////////////////////////////
	USHORT GetPartFormat(int index);

	//////////////////////////////////////////////////////////////////////////
	//获得此指定分区的相对扇区位置，如果是逻辑分区的话,这里指的是，相对扩展分
	//区起始位置的扇区数，如果是主分区的话这里指的是相对于磁盘其实位置的扇区数
	//param
	//		index	指定的分区序号
	//return
	//		相对山区号
	//		如果index有无的话返回  0xFFFFFFFF
	//////////////////////////////////////////////////////////////////////////
	DWORD GetRelativeSectors(int index);

	//////////////////////////////////////////////////////////////////////////
	//获得指定分区的扇区数
	//param
	//		index	指定的分区序号
	//return
	//		扇区总数  如果index无效的话返回-1
	//////////////////////////////////////////////////////////////////////////
	LONG_INT GetPartSectorCount(int index);
	
	//////////////////////////////////////////////////////////////////////////
	//获得指定区域相对磁盘的实际位置
	//param
	//		index	指定的分区序号
	//return
	//		相对磁盘起始位置的实际山区号  如果index无效的话返回-1
	//////////////////////////////////////////////////////////////////////////
	LONG_INT GetPartOffset(int index);

	//////////////////////////////////////////////////////////////////////////
	//判断指定的节点是否为活动分区
	//param
	//		index	指定的分区序号
	//return
	//		如果是活动分区的话返回TRUE，否则FALSE
	//////////////////////////////////////////////////////////////////////////
	BOOL	 IsActivityPart(int index);
	
	//////////////////////////////////////////////////////////////////////////
	//获得设备的名字
	//////////////////////////////////////////////////////////////////////////
	inline const WCHAR* GetDevName(void) { return mDevName; }

	//////////////////////////////////////////////////////////////////////////
	//从磁盘读取数据
	//param
	//		buf		读取数据的缓存
	//		off		读取数据的偏移
	//		dwRead	将要读取的数据的大小
	//return
	//		操作结果 ,DR_INIT_ERR设备没有打开
	//		读写指针御姐 DR_DEV_CTRL_ERR
	//***********************************************************************************/
	DRES ReadData(void* buf , LONG_INT off , DWORD dwRead = SECTOR_SIZE);

	//////////////////////////////////////////////////////////////////////////
	//获得当前磁盘的每扇区字节数，因为现在这这个程序值处理扇区大小为512字节的
	//磁盘，所这里返回的值总是512
	//////////////////////////////////////////////////////////////////////////
	int GetBytePerSec();

	//////////////////////////////////////////////////////////////////////////
	//获得当前磁盘的每磁道扇区数 
	//return 每磁道扇区数,如果磁盘没有打开的话返回-1
	//////////////////////////////////////////////////////////////////////////
	int GetSectorPerTrack();
	
	//////////////////////////////////////////////////////////////////////////
	//获得当前磁盘的每柱面磁道数
	//return 每柱面磁道数,如果磁盘没有打开的话返回0
	//////////////////////////////////////////////////////////////////////////
	DWORD GetTracksPerCylinder();

	//////////////////////////////////////////////////////////////////////////
	//获得当前磁盘的每柱面数
	//return 每柱面数,如果磁盘没有打开的话返回-1
	//////////////////////////////////////////////////////////////////////////
	LONG_INT GetCylinders();

};

//////////////////////////////////////////////////////////////////////////
//FAT32文件系统的操作的封装
//////////////////////////////////////////////////////////////////////////

/*********************************************************
查找文件的回调函数
param
	name	找到的文件名字,如果等于NULL表示查找完毕,如
			果是遇到短文件名，那就返回大写的形式
return 
	TRUE	需要继续列举
	FALSE	不需要继续列举	
**********************************************************/
typedef BOOL ( * FIND_FILE)(const WCHAR*  name);

/*********************************************************
列举被删除了的文件的回调函数
param
	file	找到的被删除了的文件句柄,此句柄在使用完了的之后
			必须关闭，否则内存泄露，如果此域为NULL则表示已经
			查找结束
return 
	TRUE	需要继续列举
	FALSE	不需要继续列举	
**********************************************************/
typedef BOOL (*FIND_DEL_FILE)(DFat32File file);



class  DFat32;
//FAT32的文件管理类
class DTOOL_API DFat32File
{	
	friend DFat32;
private:
	BYTE	mAttr;				//此文件的属性
	BYTE	mStatus;			//状态
	
	USHORT  mCrtTime;			//文件的创建时间
	USHORT  mCrtDate;			//文件的创建日期
	
	USHORT	mLstAccDate;		//文件的最后的访问日期

	USHORT  mWrtTime;			//文件的最后的写的时间
	USHORT  mWrtDate;			//文件的最后的写的日期
	
	DWORD	mStartClust;		//起始簇号
	DWORD	mFileSize;			//文件的大小
	DWORD	mPointer;			//当前文件读写指针
	DWORD   mIndex;				//此文件对应的段文件入口所在父目录中的目录项索引
	
	std::wstring mPath;			//此文件的路径

	DFat32* mFS;				//此文件所属的文件系统

	//////////////////////////////////////////////////////////////////////////
	//初始化当前文件的对象的属性 
	//////////////////////////////////////////////////////////////////////////
	DRES InitFile( PVOID entr ,const WCHAR* path ,DFat32 * fs);

public:
	DFat32File();
	virtual ~DFat32File();

	//////////////////////////////////////////////////////////////////////////
	//获得指定文件的文件名,如果文件没有初始化的话的返回的是NULL
	//////////////////////////////////////////////////////////////////////////
	const WCHAR* GetFileName();

	//////////////////////////////////////////////////////////////////////////
	//判断当前文件结构是否是一个目录,如果此文件是一个目录的话返回TRUE，否则返
	//回FALSE。注意若果文件没有打开的话返回的也是FALSE
	//////////////////////////////////////////////////////////////////////////
	BOOL IsDir();

	//////////////////////////////////////////////////////////////////////////
	//判断一个文件是否已经到了文件尾,如果文件已经到了文件尾的话返回TRUE,否则返
	//回FALSE。注意若果文件没有打开的话返回的也是FALSE回
	//////////////////////////////////////////////////////////////////////////
	BOOL IsEOF();

	//////////////////////////////////////////////////////////////////////////
	//判断当前文件是否有效
	//////////////////////////////////////////////////////////////////////////
	BOOL IsValid();

	//////////////////////////////////////////////////////////////////////////
	//关闭当前文件
	//////////////////////////////////////////////////////////////////////////
	void Close();

	//////////////////////////////////////////////////////////////////////////
	//读取指定的文件的数据
	//param
	//		file		将要读取的文件
	//		buf			读取数据的缓存
	//		dwReaded	实际得到的数据的大小
	//		dwToRead	需要读取的数据的大小
	//return
	//		操作结果 
	//		DR_IS_DIR	指定的文件是一个目录，不是一个文件
	//	
	//////////////////////////////////////////////////////////////////////////
	DRES ReadFile(char* buf, DWORD* dwReaded, DWORD dwToRead = SECTOR_SIZE);

	//////////////////////////////////////////////////////////////////////////
	//获得文件、目录内容的其实扇区号
	//如果出错的返回0
	//////////////////////////////////////////////////////////////////////////
	DWORD GetStartSec();

	//////////////////////////////////////////////////////////////////////////
	//获得当前文件内容的起始簇号
	//如果出错的返回0
	//////////////////////////////////////////////////////////////////////////
	DWORD GetStartClust();

	//////////////////////////////////////////////////////////////////////////
	//获得文件中用的扇区数
	//实际数据不一定有这么大
	//////////////////////////////////////////////////////////////////////////
	DWORD GetSecCount();

	//////////////////////////////////////////////////////////////////////////
	//获得文件的实际大小（字节数）
	//错误时 返回0
	//////////////////////////////////////////////////////////////////////////
	DWORD GetFileSize();

	//////////////////////////////////////////////////////////////////////////
	//以下是获得文件的创建，修改，访问时间。其中访问只包含日期部分。所有的时间
	//都是基于UTC的
	//////////////////////////////////////////////////////////////////////////
	LONG_INT GetCreateTime(void);
	LONG_INT GetWriteTime(void);
	LONG_INT GetAccessTime(void);

	//////////////////////////////////////////////////////////////////////////
	//获得文件的属性,此函数返回的是一个位的集合 ，多个ATTR_*相或的结果
	//////////////////////////////////////////////////////////////////////////
	BYTE	 GetFileAttr();

	//////////////////////////////////////////////////////////////////////////
	//获得在父目录中的索引号
	//return
	//		如果文件没有打开的话返回0xFFFFFFFF
	//////////////////////////////////////////////////////////////////////////
	DWORD	GetParentIndex();


};//, *PFAT32FIL;


class DTOOL_API DFat32
{
	friend DFat32File;
private:
	HANDLE		mDev;							//设备
	WCHAR		mDevName[DEVICE_NAME_LEN+1];	//设备名字
	LONG_INT	mFSOff;							//文件系统化的偏移(扇区)
	BYTE		mSecPerClus;					//每簇扇区数
	DWORD		mMaxClust;						//最大的可分配簇号
	USHORT      mResSec;						//保留的扇区数(第一个fat之前的扇区数)
	USHORT		mFSinfoSec;						//FSinfo扇区所在的扇区号(保留扇区中 通常为1)
	DWORD		mSecsPerFAT;					//每个FAT占的扇区数
	DWORD		mSectors;						//分区总山区数	
	DWORD		m1stDirClut;					//第一个根目录所在的簇的簇号
	BYTE		mFATs;							//FAT表数
	BOOL		mIsViewChged;					//数据窗口中的数据是否修改了
	DWORD		mViewSec;						//数据窗口的扇区号
	BYTE		mView[SECTOR_SIZE];				//数据缓存窗口
private:

	//////////////////////////////////////////////////////////////////////////
	//将数据写到磁盘
	//param
	//		buf			要写的数据缓存
	//		off			写数据的偏移(扇区 ,相对于本分区其实位置)
	//		dwWrite		将要写的数据的大小
	//return
	//		操作结果
	//////////////////////////////////////////////////////////////////////////
	DRES WriteData(void* buf , DWORD off, DWORD dwWrite = SECTOR_SIZE);
		
	//////////////////////////////////////////////////////////////////////////
	//移动数据视图所在的扇区
	//param
	//		sec			将要移到的数据窗口 如果此域是0的话，只是将数据写会磁盘而已
	//return 
	//		操作结构
	//////////////////////////////////////////////////////////////////////////
	DRES MoveView(DWORD sec);
	
	//////////////////////////////////////////////////////////////////////////
	//通过制定的路径获得其入口结构
	//param
	//		path		要获得其入口结构的Unicode字符串路径
	//		entry		path所指定的文件或目录入口
	//return 
	//		操作结构
	//////////////////////////////////////////////////////////////////////////
	DRES GetDirEntry(const WCHAR* path ,PVOID entry);

	//////////////////////////////////////////////////////////////////////////
	//定位指定的簇号中的制定的入口，也就是在通过entry.mStartClust指定的簇作为起始簇，的目
	//录中，第index个入口
	//param
	//		entry		要定位的目录结构
	//		index		制定的目录索引
	//return 
	//		操作结构
	//////////////////////////////////////////////////////////////////////////
	DRES PosEntry(PVOID entry , WORD index);
	
	//////////////////////////////////////////////////////////////////////////
	//从路径path中获得获得第一段该构造entry,检查文件名的合法性
	//param
	//		path		指定的路径,执行成功后返回下一段的起始位置
	//		entry		需要构造的入口(可能是半成品)
	//return 
	//		操作结构代码
	//////////////////////////////////////////////////////////////////////////
	DRES GetSegName(const WCHAR** path, PVOID entry);

	//////////////////////////////////////////////////////////////////////////
	//从路径path中获得获得第一段(表示已经删除来的文件)来构造entry,检查文件名的合法性,第一个字符必须
	//为"*"
	//param
	//		path		指定的路径,执行成功后返回下一段的起始位置
	//		entry		需要构造的入口(可能是半成品)
	//return 
	//		操作结构代码
	//////////////////////////////////////////////////////////////////////////
//	DRES GetDelSegName(const WCHAR** path, PVOID entry);
	
	//////////////////////////////////////////////////////////////////////////
	//在entry制定扇区中查找entry制定的目录(文件)入口(从定位)
	//param
	//		entry		从定位的目录项
	//return 
	//		操作结构代码
	//////////////////////////////////////////////////////////////////////////
	DRES FindEntry(PVOID entry);

	//////////////////////////////////////////////////////////////////////////
	//查找一个已经删除了的入口,在entry制定扇区中查找entry制定的目录(文件)入口(从定位)
	//param
	//		entry		从定位的目录项
	//return 
	//		操作结构代码
	//////////////////////////////////////////////////////////////////////////
	DRES FindDelEntry(PVOID entry);

	//////////////////////////////////////////////////////////////////////////
	//比较长名入口dir中的文件名是否和path中的对应字符字符相符
	//param
	//		path		原路径
	//		dir			要匹配路径的入口结构
	//return 
	//		匹配是否成功
	//////////////////////////////////////////////////////////////////////////
	BOOL CompLFN(const WCHAR* path, BYTE* dir);

	//////////////////////////////////////////////////////////////////////////
	//设置一段长文件名
	//param
	//		path		名字缓存
	//		dir			待取出名字的入口
	//return 
	//		操作结构
	//////////////////////////////////////////////////////////////////////////
	DRES SetLFN( WCHAR* path, BYTE* dir);
	
	//////////////////////////////////////////////////////////////////////////
	//在长文件名缓存前面插入指定的文件名部分
	//param
	//		path		名字缓存
	//		dir			待取出名字的入口
	//return 
	//		操作结构
	//////////////////////////////////////////////////////////////////////////
	DRES AppLFN( WCHAR* path, BYTE* dir);

	//////////////////////////////////////////////////////////////////////////
	//将当前的入口移到下一个入口
	//param
	//		entry		当前入口
	//return 
	//		操作操作状态
	//////////////////////////////////////////////////////////////////////////
	DRES NextEntry(PVOID entry);

	//////////////////////////////////////////////////////////////////////////
	//计算一个短文件名的校验和
	//param
	//		pFcbName		需要计算的短文件名
	//return 
	//		校验和
	//////////////////////////////////////////////////////////////////////////
	BYTE ChkSum(BYTE* pFcbName);

	//////////////////////////////////////////////////////////////////////////
	//短文件名的比较
	//param
	//		path1			待比较的段文件名1
	//		path2			带比较的短文件名2
	//return 
	//		TRUE		相等
	//		FALSE		不相等
	//////////////////////////////////////////////////////////////////////////
	BOOL CompSFN(const char* path1, const char* path2);

	//////////////////////////////////////////////////////////////////////////
	//抠出短文件名入口的名字
	//param
	//		path		名字缓存
	//		dir			待取出名字的入口
	//return 
	//		操作结构
	//////////////////////////////////////////////////////////////////////////
	DRES SetSFN( WCHAR* path, BYTE* dir);

	//////////////////////////////////////////////////////////////////////////
	//创建一个文件句柄
	//param
	//		path		文件路径
	//		entry		要创建的文件句柄对应的段文件目录入口
	//return 
	//		创建好的文件句柄
	//////////////////////////////////////////////////////////////////////////
	DRES NewFileHandle(DFat32File* file, PVOID entry ,const WCHAR* path);

	//////////////////////////////////////////////////////////////////////////
	//查找下一个已经删除了的文件
	//param
	//		finder	查找句柄
	//		file	找到的结果
	//return	操作结果
	//////////////////////////////////////////////////////////////////////////
	DRES FindNextDelFile(FINDER finder , DFat32File* file);

	//////////////////////////////////////////////////////////////////////////
	//超找下一个存在的文件
	//param
	//		finder	查找句柄
	//		file	找到的结果
	//return	操作结果
	//////////////////////////////////////////////////////////////////////////
	DRES FindNextExistFile(FINDER finder , DFat32File* file);
public:
	DFat32(void);
	virtual ~DFat32(void);

	//////////////////////////////////////////////////////////////////////////
	//从第一个FAT表中获得指定簇号的表项值
	//param
	//		clust		指定的簇号
	//return 
	//		表项值	1，簇号无效  0xFFFFFFFF  设备IO操作错误
	//////////////////////////////////////////////////////////////////////////
	DWORD GetFATFromFAT1(DWORD clust);

	//////////////////////////////////////////////////////////////////////////
	//从第二个FAT表中获得指定簇号的表项值
	//param
	//		clust		指定的簇号
	//return 
	//		表项值	1，簇号无效  0xFFFFFFFF  设备IO操作错误
	//////////////////////////////////////////////////////////////////////////
	DWORD GetFATFromFAT2(DWORD clust);

	//////////////////////////////////////////////////////////////////////////
	//计算指定簇号的起始扇区号
	//param
	//		clust		指定的簇号
	//return 
	//		表项值	0，簇号无效
	//////////////////////////////////////////////////////////////////////////
	DWORD ClustToSect(DWORD clust);

	//////////////////////////////////////////////////////////////////////////
	//计算指定的扇区号所在的簇号,如果无效的话返回0
	//param
	//		sector		指定的扇区号
	//return 
	//		簇号,如果无效的话返回0
	//////////////////////////////////////////////////////////////////////////
	DWORD SectToClust(DWORD sector);

	//////////////////////////////////////////////////////////////////////////
	//获得当前文件系统的扇区大小
	//如果文件系统打开失败的话 返回的是0
	//////////////////////////////////////////////////////////////////////////
	DWORD GetSecCount();
	
	//////////////////////////////////////////////////////////////////////////
	//初始化话DFAT32的文件系统化实例,操作完后可以通过IsDevOpened判断是否已经打
	//开了设备,正确打开的设备需要调用CloseDev来关闭
	//param
	//	name		存储设备的名字  可以是一个屋里磁盘或者是一个卷
	//	offset		DFAT32文件系统在这一个设备上的偏移 
	//return
	//	操作结果
	//			DR_ALREADY_OPENDED  当前设备已经打开了，样重新打开的话要先关闭
	//////////////////////////////////////////////////////////////////////////
	DRES OpenDev(const WCHAR* name, LONG_INT offset);

	//////////////////////////////////////////////////////////////////////////
	//判断当前设备是否已经打开了
	//////////////////////////////////////////////////////////////////////////
	inline BOOL IsDevOpened() { return wcslen(mDevName) > 0; }

	//////////////////////////////////////////////////////////////////////////
	//关闭当前打开的设备
	//////////////////////////////////////////////////////////////////////////
	void CloseDev();

	//////////////////////////////////////////////////////////////////////////
	//从磁盘读取数据
	//param
	//	buf			读取数据的缓存
	//	off			读取数据的偏移(扇区 ,相对于本分区其实位置)
	//	dwRead		将要读取的数据的大小
	//return
	//	操作结果
	//////////////////////////////////////////////////////////////////////////
	DRES ReadData(void* buf , DWORD off , DWORD dwRead = SECTOR_SIZE);
	
	//////////////////////////////////////////////////////////////////////////
	//以Unicode的路径打开指定的文件
	//param
	//	path		文件的绝对路径Unocode
	//	file		打开的文件
	//return
	//	操作结果
	//////////////////////////////////////////////////////////////////////////
	DRES OpenFileW(const WCHAR* path , DFat32File* file);

	//////////////////////////////////////////////////////////////////////////
	//以ASCII的文件路径打开一个指定的文件
	//param
	//	path		文件的绝对路径(ascii)
	//	file		打开的文件
	//return
	//	操作结果
	//////////////////////////////////////////////////////////////////////////
	//DRES OpenFileA(const char* path , DFat32File* file);
		
	//////////////////////////////////////////////////////////////////////////
	//列举一个目录中的所有文件或者目录
	//param
	//	dirc		需要列举子目录和文件的目录
	//	listFun		列举文件的回调函数,找到一个文件时会哦返回字名字，
	//return
	//	操作结果
	//////////////////////////////////////////////////////////////////////////
	DRES ListFile(DFat32File*  dirc, FIND_FILE listFun);

	//////////////////////////////////////////////////////////////////////////
	//开始一个文件的查找过程,每次调用成功后都都需要调用FindClose来释放查找句柄
	//此函数需要和FindNextFileW组合起来完成查找
	//param
	//		dir		被查找的目录,不是文件的话返回错误
	//		finder	用于返回一个查找的文件句柄
	//		findDel	是否是查找已经删除了的文件
	//return	
	//			DR_INVALED_PARAM  dir或者finder为空
	//			DR_INVALID_HANDLE dir是一个无效的句柄
	//			DR_IS_FILE		  dir是一个文件件，而不是一个目录
	//////////////////////////////////////////////////////////////////////////
	DRES FindFile(DFat32File* dir , FINDER* finder , BOOL findDel = FALSE);

	//////////////////////////////////////////////////////////////////////////
	//查询号下个文件
	//param
	//			finder	查找句柄,此举并由FindFile创建
	//			file	用于返回一个已经找到的文件
	//return	操作结果
	//				DR_FAT_EOF	 已经查找问了，file的内容不做处理
	//////////////////////////////////////////////////////////////////////////
	DRES FindNextFileW(FINDER finder , DFat32File* file );

	//////////////////////////////////////////////////////////////////////////
	//结束一个查找过程
	//param	 finder  是有FindFile返回的一个查找句柄
	//////////////////////////////////////////////////////////////////////////
	void FindClose(FINDER finder);

	//////////////////////////////////////////////////////////////////////////
	//列举一个目录中一个所有已经被删除的了的文件
	//param
	//	dirc		需要列举子目录和文件的目录
	//	listFun		找到一个被删除了的文件后要调用的回调函数
	//return
	//	操作结果
	//////////////////////////////////////////////////////////////////////////
	DRES ListDelFile(DFat32File* dirc, FIND_DEL_FILE listFun);

	//////////////////////////////////////////////////////////////////////////
	//获得没簇的扇区数
	//如果设备没有打开的话返回0
	//////////////////////////////////////////////////////////////////////////
	BYTE GetSecPerClust();



	//////////////////////////////////////////////////////////////////////////
	//判断指定的设备是否含有FAT32的标记。准确的来讲这并不是判断一个卷是否是一
	//个FAT32卷的标志。Microsoft说判断方式是卷的簇数的大小，但是这只是在FAT系
	//列中，如果有NTFS的话,我想就没法判断了。我做过的一个虚拟磁盘，并没有用FAT32
	//标记，但是Windows也可以很好的识别。所以通过这种方式来判断的话会有误差
	//param
	//		cDevName	设备的名字
	//		offset		文件系统在设备上的偏移，一般如果只是一个卷的话这个值为0
	//return	DR_OK	指定设备区域含有FAT32标记
	//			DR_NO	指定设备区域没有FAT32标记
	//			DR_INVALED_PARAM	参数错误
	//			其他（如DR_OPEN_DEV_ERR）设备错误
	//////////////////////////////////////////////////////////////////////////
	static DRES IsContainFat32Flag(const WCHAR* cDevName , LONG_INT offset);

	//////////////////////////////////////////////////////////////////////////
	//获得当前卷的卷标
	//param
	//		cNameBuf	卷标的缓存
	//		len			缓存的长度
	//return 操作结果 DR_BUF_OVER缓存不够
	//////////////////////////////////////////////////////////////////////////
	DRES GetVolumeName(OUT WCHAR* cNameBuf, IN int len);

	//////////////////////////////////////////////////////////////////////////
	//获得设备的名字
	//return	设备的名字
	//				如果设备以打开的话就返回设备名字，否则NULL
	//////////////////////////////////////////////////////////////////////////
	const WCHAR* GetDevName();

	//////////////////////////////////////////////////////////////////////////
	//获得保留扇区数
	//return	保留扇区数
	//			如果设备还没又打开的话返回0
	//////////////////////////////////////////////////////////////////////////
	USHORT GetReserveSector();

	//////////////////////////////////////////////////////////////////////////
	//获得每个FAT表所占用的扇区数
	//return	每FAT扇区数
	//			如果设备还没有打开的话返回0
	//////////////////////////////////////////////////////////////////////////
	DWORD GetSectorPerFAT();

	//////////////////////////////////////////////////////////////////////////
	//获得FSInfo所在扇区号
	//return FSInfo所在扇区
	//		如果设备没有打开返回0
	//////////////////////////////////////////////////////////////////////////
	USHORT GetFSInfoSec();

	//////////////////////////////////////////////////////////////////////////
	//获得第一个根目录的簇号
	//return	第一个根目录簇号
	//		如果设备还没有打开的话返回0
	//////////////////////////////////////////////////////////////////////////
	DWORD Get1stDirClust();

	//////////////////////////////////////////////////////////////////////////
	//获得当前分区的剩余扇区数
	//return	剩余扇区数
	//		如果设备还没有打开的话返回0
	//////////////////////////////////////////////////////////////////////////
	DWORD GetRemainSectorCnt();

	//////////////////////////////////////////////////////////////////////////
	//获得当前fat32的最大簇号
	//return	最大簇号
	//		如果设备还没有打开的话返回0
	//////////////////////////////////////////////////////////////////////////
	DWORD GetMaxClustNum();

};


/************************************************************************/
/* NTFS文件的属性操作方式                                               */
/************************************************************************/
class DTOOL_API DNtfsAttr{
private://属性
	BYTE*		mAttrBuf;			//余下的数据缓存  其实这里也包含了一下数据缓存

public:	//公开方法
	DNtfsAttr();
	~DNtfsAttr();
	//////////////////////////////////////////////////////////////////////////
	//使用指定的缓存初始化当前属性,如果缓存地址的地址无效或者缓存地址无效则返回
	//参数错误，如果缓存长度的地址无效或缓存的长度不够则返回参数错误.为了节省内
	//存，里面基本没有数据缓存,数据缓存都是src中的，所以要保此属性有效的前提src
	//不被破坏
	//param		src		用来初始化属性的数据缓存其实地址
	//			len		数据缓存的长度的地址,执行成功后会返回剩下的缓存的大小
	//return	操作结果,DR_FAT_EOF表示了已经没有了属性，已经到了属性列表的末
	//			尾了,DR_INVALED_PARAM表示参数错误
	//////////////////////////////////////////////////////////////////////////
	DRES InitAttr(void* src /*, DWORD* len*/);

	/**************************************************************************/
	/*一下为简单属性检查防范，操作之前必须已经成功调用了InitAttr，否则后果自负*/
	/*当然此类基本是作为内部使用，所以一般不怎么检查参数,                      */
	/**************************************************************************/
	DWORD GetAttrType();  //获得属性的类型
	//////////////////////////////////////////////////////////////////////////
	//获得属性的字节数,包括属性的头部
	DWORD GetAllLen();    
	BOOL  IsNonResident();//是否为非驻留属性
	WORD  GetNameLen();	  //获得属性名字的长度(字符数，不包括NUL)  为0是表示没有名字  
	BOOL  IsCompressed(); //是否为压缩文件
	BOOL  IsEncrypted();  //是否为加密文件
	BOOL  IsSparse();     //是否为稀疏文件
	WORD  GetAttrID();	  //获得当前属性的ID
	//////////////////////////////////////////////////////////////////////////
	//获得属性的名字
	//param
	//		buf	用于存放名字的缓存
	//		len	缓存的长度 需要包括一个结束字符的空间
	//return	DR_OK	操作成功
	//			DR_NO	没有名字
	//			DR_BUF_OVER	缓存空间不够
	DRES  GetAttrName(WCHAR* buf , int len);
	BYTE* GetAttrHeadPtr();//获得属性的地址其实就是初始化时传来的src

	/************************************************************************/
	/* 一下书常驻属性的一些普通操作方法                                     */
	/************************************************************************/
	//////////////////////////////////////////////////////////////////////////
	//获得标准属性头的长度
	WORD  R_GetStdHeadLen();//标准属性有的长度
	DWORD R_GetAttrLen();//获得属性数据的大小
	DWORD R_GetAttrOff();//获得属性数据的偏移
	BYTE* R_GetAttrBodyPtr();//获得属性实体的地址  //除掉文件名的地址


	/************************************************************************/
	/* 一下是非驻留属性所共有的操作方法                                     */
	/************************************************************************/
	LONG_INT NR_GetStartVCN();  //获得本属性数据流的开始虚拟簇号
	LONG_INT NR_GetEndVCN();	//获得本属性数据流的结束虚拟簇号
	WORD	 NR_GetDataOff();	//获得数据流描述相对于属性头的偏移，数据应该按双字对齐
	WORD     NR_GetCmpSize();	//压缩单元的尺寸。压缩单元的尺寸必须是2的整数次幂，为0表示未压缩
	LONG_INT NR_GetAllocSize(); //属性记录数据块分配的空间的尺寸，该尺寸按簇尺寸对齐
	LONG_INT NR_GetValidSize(); //属性记录数据块的实际尺寸
	LONG_INT NR_GetInitedSize();//属性记录数据块已经初始化数据的尺寸，到目前为止该值都与属性记录DRES InitAttrList(BYTE* attrBuf)R_GetDataPtr();	//获得数据的起始地址
	BYTE*	 NR_GetDataPtr();
	DWORD	 NR_GetStdHeadLen();//获得的非常驻属性的标注属性头的长度

	/************************************************************************/
	/* 以下是文件名属性所用的操作方法(AD_FILE_NAME).						*/
	/* 此属性存储文件名属性，而且总是常驻的。就像在$AttrDef中定义的，此属性 */
	/* 最小68字节，最大578字节。 等于一个255个标准编码字符的最大文件名长度。*/
	/* 标准属性头(24 (0x18)字节)											*/
	/************************************************************************/
	DWORD FNGetFileNameLen();			//获得文件名的字符长度
	DRES  FNGetFileName(WCHAR* buf);	//获得文件名，木有NUL
	BYTE  FNGetFileNameSpase();			//获得文件名的名空间
	LONG_INT FNGetParentMftIndx();		//获得父目录的mft记录号
	DWORD FNGetFlags();					//获得dos属性
	LONG_INT FNGetRealSize();			//获得文件的实际大小
	LONG_INT FNGetAllocateSize();		//获得文件的分配大小


	/************************************************************************/
	/* 一下的操作方法是针对AD_INDEX_ROOT属性的，此属性总是常驻的，          */
	/************************************************************************/
	DWORD IRGetAttrAttrType();		//获得属性的内部的属性  ，不知道干嘛的
	DWORD IRGetIndexBlockSize();	//索引块的大小(字节) 一般是4K
	BOOL  IRIsLargeIndex();			//书否为打入口块，如果是的话，那么此目录还包含属性$INDEX_ALLOCATION
	//和$BITMAP，也就是说在其他的地方还包含了入口
	DWORD IRGetIndexEntriesSize();	//所有的索引的大小总大小
	DWORD IRGetAlloIndexEntriesSize();//分配了的索引块的大小
	BYTE* IRGetFistEntry();			//获得第一个入口的地址


	/************************************************************************/
	/* 以下是处理属性AD_INDEX_ALLOCATION的一些方法，此属性总是非常驻的，是否*/
	/* 拥有此属性,可以根据属性AD_INDEX_ROOT的IsLargeIndex()判断             */
	/************************************************************************/
	LONG_INT IAGetLCNByVCN(LONG_INT* vcn /*虚拟簇号*/, PLONG_INT ClustCnt/*用于返回占用簇数*/); //通过虚拟簇号获得逻辑簇号

	/************************************************************************/
	/* 下面数Bitmap属性的草集合                                             */
	/************************************************************************/
	//////////////////////////////////////////////////////////////////////////
	//判断一个指定的为是否设定
	//param
	//		bit 需要查找的位
	//		fs	文件系统
	//return 指定位是否已经设置
	//////////////////////////////////////////////////////////////////////////
	BOOL BMIsBitSet(LONG_INT bit , DNtfs* fs);

	/************************************************************************/
	/* AD_STANDARD_INFORMATION随性的操作集合                                                                     */
	/************************************************************************/
	DWORD SIGetFlags();	//获得dos属性



};//NtfsAttr


/************************************************************************/
/* Run的各种操作方发                                                    */
/************************************************************************/
class DTOOL_API DRun{
private://运行列表
	typedef struct _RunList{
		LONG_INT vcn;		//文件的虚拟簇号
		LONG_INT lcn;		//逻辑簇号   此域为-1是表示稀疏簇
		LONG_INT clustCnt;	//此节点对应的簇数
	}RunList , *PRunList;

public:
	DRun();
	~DRun();

	std::vector<RunList> mRunList;
	//PRunList mRunList;	//run的实际数据
	//DWORD	 mRunCnt;	//run的数量


	//////////////////////////////////////////////////////////////////////////
	//初始化运行列表，必须处理的
	//param
	//		attr	属性对象
	//return 操作结果
	//			DR_INVALED_PARAM	参数无效
	//			DR_INIT_ERR			只有非常驻属性才有RUN
	//			DR_OK				操作成功
	//////////////////////////////////////////////////////////////////////////
	DRES InitRunList(DNtfsAttr* attr);

	//////////////////////////////////////////////////////////////////////////
	//通过文件的VCN获得文件的LCN，和在在制定的LCN后面的簇数
	//param
	//		vcn		指定的VCN
	//		clustCnt 用于返回在vcn对应的lcn后面的簇数,如果此域为NULL的话，就不
	//				返回
	//return	vcn所对应的LCN,如果是-1的话则表示出错了，而-2则表示当前vcn中没
	//			有数据,(稀疏文件)
	//////////////////////////////////////////////////////////////////////////
	LONG_INT GetLCNByVCN(LONG_INT vcn , PLONG_INT clustCnt);

	//////////////////////////////////////////////////////////////////////////
	//释放资源
	//////////////////////////////////////////////////////////////////////////
	void Close();
};


/************************************************************************/
/*这里定义了一些ntfs文件的操作集合						                */
/************************************************************************/
class DTOOL_API DNtfsFile{
	friend DNtfs;
public:
	typedef struct _AttrItem{
		DWORD		id;			//属性id
		DWORD		attrType;	//属性类型 ATTR_*
		LONG_INT	mftIndex;	//当前属性所属的MFT记录 
		std::vector<BYTE> attrDataBuf;//属性的数据地址
		WORD		off;		//当前属性在当前MFT中的偏移 

		_AttrItem()
			: id(0)
			, attrType(0)
			, off(0)
		{}
	}AttrItem , *PAttrItem;
private:

	DNtfs*		mFS;			//当前记录所属的文件系统,此域当做磁记录的有效标记
	LONG_INT	mMftIdx;		//MFT中的记录号
	LONG_INT	mFilePointer;	//文件的当前读写指针

	LONG_INT	mLIStartFDT;	//对应的MFT起始物理偏移(字节)
	WORD		mFDTLen;		//对应的FDT字节数

	DWORD		mAttrCnt;		//当前文件记录中的属性总数
	std::unique_ptr<AttrItem[]> mAttrArr; //属性数组

	//这个运行时文件无名数据运行
	//获得目录的INDEX_ALLOCATION
	std::unique_ptr<DRun>		m_upRun;	//数据流

	//BYTE*		mMftHeadPtr;	
	std::vector<BYTE> mMftHeadBuf; //Mft记录的头部

protected:
	//////////////////////////////////////////////////////////////////////////
	//查找指定的属性
	//param
	//		dwAttrType  属性类型，AD_*
	//		attr		找到的属性返回缓存
	//		startIdx	要遍历属性表的起始位置，取值在[0 , mAttrCnt-1]（因为有
	//					同类型的属性 ，比如文件一般不止一个FAIL_NAME属性）。如
	//					果此域为NULL的话就从0开始找，找到第一个匹配的,否则从指
	//					定的位置开始找。如果startIdx里面的值越界了的话就返回
	//					DR_INVALID_PARAM.
	//return	DR_OK成功，DR_NO没有。如果startIdx != NULL 的话，则此域返回当前
	//			记录的索引
	//////////////////////////////////////////////////////////////////////////
	DRES FindAttribute(DWORD dwAttrType , VOID* attr , DWORD* startIdx = 0);

	//////////////////////////////////////////////////////////////////////////
	//从缓存区中初始化属性列表
	//param
	//		attrBuf	MFT的文件记录缓存区
	//return	操作结果
	//////////////////////////////////////////////////////////////////////////
	DRES InitAttrList(BYTE* attrBuf);
	
	//////////////////////////////////////////////////////////////////////////
	//实例化本记录,此方法不能从夫调用,否则内存泄露,需要从夫调用的话线调用Close
	//否则返回DR_ALREADY_OPENDED
	//param
	//		fs			此文件记录所在的文件系统
	//		mftIndex	记录在mft的索引号
	//////////////////////////////////////////////////////////////////////////
	DRES InitRecode(DNtfs* fs ,LONG_INT mftIndex);

	//////////////////////////////////////////////////////////////////////////
	//获得此文件记录中的指定的被更新序列号所替换的的区域的原值
	//param
	//		index		指定的值得索引   0~n
	//return	更新序列号所占用的区域的原值
	//////////////////////////////////////////////////////////////////////////
	WORD GetUSAItem(int index);
public:
	DNtfsFile();

	//////////////////////////////////////////////////////////////////////////
	//获得文件的实际数据存数属性(无名Data属性)
	//param		attr	用于返回找到的数据属性
	//return	操作结果
	//			DR_NO				没有指定的属性 
	//			DR_OK				操作成功
	//			DR_NO_OPEN			没有打开设备
	//			DR_INVALED_PARAM	参数错误
	//////////////////////////////////////////////////////////////////////////
	DRES FindNoNameDataAttr(DNtfsAttr* attr);

	//////////////////////////////////////////////////////////////////////////
	//获得磁记录在MFT中的索引号，如果构造失败的话，返回的是-1
	//////////////////////////////////////////////////////////////////////////
	LONG_INT GetMftIndex();

	//////////////////////////////////////////////////////////////////////////
	//判断当期那文件句柄是否有效
	//////////////////////////////////////////////////////////////////////////
	BOOL IsFileValid();

	//////////////////////////////////////////////////////////////////////////
	//获得当前问及爱你的父目录的MFT记录号,如果是错误的文件，或者查找失败的话，
	//返回-1,（注意：根目录以及所有文件系统管理文件的父目录都是更目录——0x5号
	//目录）,
	//////////////////////////////////////////////////////////////////////////
	LONG_INT GetParentMftIndex();
	
	//////////////////////////////////////////////////////////////////////////
	//一下是获得NTFS文件的四个时间（创建时间，文件数据修改时间，文教案MFT记录
	//修改时间,文件最后一次读取时间）,在这里都是转化了的Unix时间，以秒为单位，
	//注意不是本地时间可以使用time.h中的时间进行本地时区转换
	//////////////////////////////////////////////////////////////////////////
	LONG_INT GetCreateTime();
	LONG_INT GetAlteredTime();
	LONG_INT GetMFTChgTime();
	LONG_INT GetReadTime();

	//////////////////////////////////////////////////////////////////////////
	//判断当前文件记录是否是文件夹,这里是通过FILE_RECODE_HEAD中的标志判断
	//////////////////////////////////////////////////////////////////////////
	BOOL IsDir();

	//////////////////////////////////////////////////////////////////////////
	//获得当前文件的文件名
	//param
	//		nameBuf		名字缓存区
	//		len			缓存区的长度(字节)
	//		nameSpace	文件名的命名空间(NS_*),这里默认是任何名空间都可以，说
	//					NS__ALL,的话是先搜索win32文件名，没有的话就再找其他的，
	//					也就是说win32文件名空间优先
	//return	操作状态,DR_BUF_OVER(缓存不够),DR_NO_FILE_NAME没有找到指定文
	//			件名空间的文件名属性
	//////////////////////////////////////////////////////////////////////////
	DRES GetFileName(WCHAR* nameBuf , DWORD len , BYTE nameSpace = NS__ALL);

	//////////////////////////////////////////////////////////////////////////
	//获得文件的属性,这里的属性的是以ATTR_*开头的属性集合,可能是多个属性值相遇
	//的结果,这个属性值应是使用的FILE_NAME中的，而不是STD_INFO中的，STD_INFO有
	//时不会包含一些ntfs特有的属性
	//////////////////////////////////////////////////////////////////////////
	DWORD GetDOSAttr();

	//////////////////////////////////////////////////////////////////////////
	//获得属性域的总数，这并不是ATTR_*，而是ntfs信息属性
	//////////////////////////////////////////////////////////////////////////
	DWORD GetAttrCount();

	//////////////////////////////////////////////////////////////////////////
	//获得文件的属性
	//param
	//		index	属性序号 >=0, <  GetAttrCount()
	//return
	//		属性类型
	//		NULL	索引无效，或者文件没有打开
	//////////////////////////////////////////////////////////////////////////
	PAttrItem GetAttr(DWORD index);

	//////////////////////////////////////////////////////////////////////////
	//查找指定的属性
	//param
	//		dwAttrType  属性类型，AD_*
	//		startIdx	要遍历属性表的起始位置，取值在[0 , mAttrCnt-1]（因为有
	//					同类型的属性 ，比如文件一般不止一个FAIL_NAME属性）。如
	//					果此域为NULL的话就从0开始找，找到第一个匹配的,否则从指
	//					定的位置开始找。如果startIdx里面的值越界了的话就返回
	//					DR_INVALID_PARAM.在函数中不会改变此域的值
	//return	如果属性存在的话则返回指定的属性对象，否则NULL
	//////////////////////////////////////////////////////////////////////////
	PAttrItem FindAttribute(DWORD dwAttrType , const DWORD* startIdx = 0);


	//////////////////////////////////////////////////////////////////////////
	//获得此文件实际分配大小,文件的实际大小保存在文件的无名数据属性中，而不是
	//文件名属性中。如果文件比较小的话，文件的无名数据属性就会是常驻的，而里面
	//的ATTR_DatSz字段就表示文件数据字节数。而文件无名数据属性的驻留也只有创建
	//的时侯,如果文件的大小不是很大的时候才可以,否则一般是非驻留的。当文件打到
	//非驻留时，然后再修改文件，将文件截断到只有几个字节时文件也还是非驻留的，
	//不会因为文件的截断问将非驻留文件改为驻留文件。而当无名数据时非驻留数时，
	//文件的实际大小(字节)有非驻留属性的ATTR_ValidSz指定,而实际的占用空间则由
	//ATTR_AllocSz来确定，这个值也是一字节为单位的，他是簇大小的整数倍
	//////////////////////////////////////////////////////////////////////////
	LONG_INT GetRealSize();

	//////////////////////////////////////////////////////////////////////////
	//获得此文件所分配的空间大小,如果是非常驻的文件的话返回的是0
	//////////////////////////////////////////////////////////////////////////
	LONG_INT GetAllocSize();

	//////////////////////////////////////////////////////////////////////////
	//通过文件的VCN获得文件的LCN，和在在制定的LCN后面的簇数
	//param
	//		vcn		指定的VCN
	//		clustCnt 用于返回在vcn对应的lcn后面的簇数,如果此域为NULL的话，就不
	//				返回
	//return	vcn所对应的LCN,如果是-1的话则表示出错了，而-2则表示当前vcn中没
	//			有数据,(稀疏文件)
	//////////////////////////////////////////////////////////////////////////
	LONG_INT GetLCNByVCN(LONG_INT vcn , PLONG_INT clustCnt);

	//////////////////////////////////////////////////////////////////////////
	//读取文件当前指针处的指定大小的数据，次方发只针对有无名数据属性的文件，不
	//不适合系统保留的文件.如果是系统保留文教案的话，会返回DR_OK，然后dwReaded
	//会置0.
	//param	
	//		buf		 取数据的缓存
	//		dwReaded 已经读取到的数据大小(字节)
	//		dwToRead 将要读取的数据的字节数
	//return	操作成功的话。DR_IS_DIR-当前文件是一个目录。
	//////////////////////////////////////////////////////////////////////////
	DRES ReadFile(char* buf, DWORD* dwReaded, DWORD dwToRead);

	//////////////////////////////////////////////////////////////////////////
	//判断是否到了文件结尾
	//////////////////////////////////////////////////////////////////////////
	BOOL IsEOF();

	//////////////////////////////////////////////////////////////////////////
	//设置文件的当前读取指针,
	//param
	//		ptr		要一定的字节数
	//		dwMoveMethod 要移动的相对位置 FILE_POS*
	//return 操作状态成功返回 DR_OK，否则返回 DR_INVALED_PARAM
	//////////////////////////////////////////////////////////////////////////
	DRES SetFilePointer(LONG_INT ptr , BYTE dwMoveMethod);

	//////////////////////////////////////////////////////////////////////////
	//关闭已经打开的文件，主要用释放分配的资源，如果一个已经打开的文件没有释放
	//的话，将会导致内存泄露
	//////////////////////////////////////////////////////////////////////////
	void Close();

	//////////////////////////////////////////////////////////////////////////
	//获得MFT记录的其实扇区号
	//////////////////////////////////////////////////////////////////////////
	LONG_INT GetMftStartSec();

	//////////////////////////////////////////////////////////////////////////
	//获得FDT的物理偏移位置
	//return 偏移
	//			如果返回0则表示没有设置位置
	//////////////////////////////////////////////////////////////////////////
	LONG_INT GetFDTOffset();

	//////////////////////////////////////////////////////////////////////////
	//获得FDT的长度 
	//return 长度
	//			如果返回0则表示没有设置FDT的位置
	//////////////////////////////////////////////////////////////////////////
	WORD GetFDTLen();
};





/************************************************************************/
/* NTFS解析操作方法集合                                                 */
/************************************************************************/
class DTOOL_API DNtfs
{
	friend DNtfsFile;

	/************************************************************************/
	/* MFT记录块，这样做的目的是因为有些情况MFT不是一个整体                 */
	/************************************************************************/
	typedef struct _MFT_BLOCK{
		LONG_INT	liStartMft;		//此块的起始记录号
		LONG_INT	liMftCnt;		//此MFT记录块的记录总数
		LONG_INT	liStartSector;	//此块的起始扇区号
	}MFT_BLOCK , *PMFT_BLOCK;

private:
	std::wstring mDevName;	//设备的名字  ,更具此值判断文件系统是否已经开好了
	LONG_INT	mFSOff;		//设备上的ntfs文件文件系统的物理偏移  (扇区)
	LONG_INT	mCluForMFT;	//$MFT的逻辑簇号
	LONG_INT	mCluForMFTMirr;	//$MFTMirr的逻辑簇号
	BYTE		mSecPerClu;	//每簇的扇区数
	LONG_INT	mAllSec;	//总扇区数
	HANDLE		mDev;		//当前打开的设备句柄
	PMFT_BLOCK	mPMftBlock;	//Mft块序列
	DWORD		mMftBlockCnt;//KFT快数量
protected:
	
	//////////////////////////////////////////////////////////////////////////
	//读取一条mft中的文件记录
	//param
	//		buf			读取到的数据存放缓存
	//		index		MFT索引号
	//return			操作结果，正常时（DR_OK）
	//////////////////////////////////////////////////////////////////////////	
	DRES ReadMFT(void* buf , PLONG_INT index);

	//////////////////////////////////////////////////////////////////////////
	//文件名的匹配
	//param
	//			src1,src2		两个需要比较的文件字符串
	//			len				要比较大的长度
	//			caseSensitiv	 文件名是否大小写铭感
	//return	相等返回 0
	//////////////////////////////////////////////////////////////////////////
	static int FileNameCmp(const WCHAR * src1,const WCHAR * src2 , int len , BOOL caseSensitiv = false);

	//////////////////////////////////////////////////////////////////////////
	//在指定的目录更具名字产找文件或者目录,可以通过制定文件的属性来决定找的是文
	//件还是目录，这里有一个问题，如果设置的查找的没有区分是文件还是目录的话，
	//程序会找到第一个字符串匹配的文件，之后的就不管了。这个方法是通过搜索每一
	//个vcn对应的lcn中的数据来查找，这样的如果数据量特别多的话相对较慢，但是内存
	//的消耗要小一些
	//param
	//		dir		指定mft，如果为-1 的就是更目录
	//		name	要查找的名字
	//		len		名字的长度
	//		mftIdx	如果找到了的话，就在这里返回其在mft中的索引
	//		attr    要匹配的NTFS文件属性  (ATTR_*),ATTR_NTFS_MASK表示所有的属性
	//return 找到了的话返回DR_OK,否则其他
	//////////////////////////////////////////////////////////////////////////
	DRES FindItemByName(LONG_INT dir , const  WCHAR* name, int len , PLONG_INT mftIdx , DWORD attr = ATTR_NTFS_MASK);


	//////////////////////////////////////////////////////////////////////////
	//遍历指定的目录，用于超找指定的文件(遍历B+树),此函数的功能和FindItemByName
	//一样，但是这个方法是以b+数为基础遍历的，如果数据量特别多的话，遍历较
	//FindItemByName要快，但是内存消耗相对交多，这里是用递归实现的
	//param		
	//		dir		指定的目录的mft记录号,-1表示根目录
	//		name	要查找的文件名
	//		len		文件名长度
	//		mftIdx	找到了的文件的mft记录号
	//		attr	要找的文件的属性
	//		pLIStartFDT 找到的文件的FDT起始物理偏移地址
	//		fdtLen	找到的FDT的长度
	//return	DR_OK找到了，其他的失败了,DR_NO没有找到,DR_IS_FILE-dir指定的一
	//		个文件
	//////////////////////////////////////////////////////////////////////////
	DRES FindItemByName2(LONG_INT dir , const  WCHAR* name, int len , PLONG_INT mftIdx , PLONG_INT pLIStartFDT , WORD* fdtLen /*, DWORD attr = ATTR_NTFS_MASK*/);
	
	//////////////////////////////////////////////////////////////////////////
	//遍历IndexBlock,被WalkDir调用 查找一个指定的文件
	//param
	//			root	vcn所属的目录
	//			vcn		将要进入的block所属vcn
	//			name	要查找的文件名
	//			len		文件名的长度
	//			mftIdx	找到了的话用于返回mft记录号
	//			attr	要超找的文件属性
	//			pLIStartFDT	找到的FDT的物理偏移
	//			fdtLen	找到的FDT的长度
	//return	DR_OK表示已经找到,DR_ON没有找到,其他的话表示出错了
	//////////////////////////////////////////////////////////////////////////
	DRES WalkNode(DNtfsFile* root , LONG_INT vcn , const  WCHAR* name, int len , PLONG_INT mftIdx  , PLONG_INT pLIStartFDT , WORD* fdtLen /*, DWORD attr = ATTR_NTFS_MASK*/);

	//////////////////////////////////////////////////////////////////////////
	//初始化MFT块结构
	//return	操作结果
	//			DR_OK	操作成功
	//////////////////////////////////////////////////////////////////////////
	DRES	InitMFTBlock();

public:
	DNtfs();
	~DNtfs();

	//////////////////////////////////////////////////////////////////////////
	//读取当前设备的指定的数据
	//param	
	//		buf		数据缓存
	//		off		要读取的数据偏移，相对当前分区的起始位置
	//		dwReadCnt 数据的总数  字节数
	//		isOffSec  off是扇区偏移则为TRUE，字节偏移则FALSE
	//return	操作结果
	//			off越界的话 返回DR_DEV_CTRL_ERR
	//////////////////////////////////////////////////////////////////////////
	DRES ReadData(void* buf , PLONG_INT off , DWORD dwReadCnt , BOOL isOffSec = TRUE);


	//////////////////////////////////////////////////////////////////////////
	//打开指定的设备上的ntfs文件系统
	//param
	//		devName		设备名字
	//		off			在设备上的ntfs物理偏移
	//return			操作结果，正常时（DR_OK）
	//////////////////////////////////////////////////////////////////////////
	DRES OpenDev(const WCHAR* devName, const PLONG_INT off);

	//////////////////////////////////////////////////////////////////////////
	//关闭当前打开的设备
	//////////////////////////////////////////////////////////////////////////
	void CloseDev();

	//////////////////////////////////////////////////////////////////////////
	//判断设备是否已经正确打开了
	//////////////////////////////////////////////////////////////////////////
	BOOL IsDevOpened();
	
	//////////////////////////////////////////////////////////////////////////
	//通过mft的索引号获得文件记录,此操作如果成功的话，需要使用Close来释放资源，
	//否则会内存泄露
	//param	
	//		file	用于返回文件记录的记录缓存区
	//		idx		mft的索引
	//return	操作成功DR_OK
	//////////////////////////////////////////////////////////////////////////
	DRES OpenFileW(DNtfsFile *file , LONG_INT idx);
	DRES OpenFileW(DNtfsFile *file , int idx);

	//////////////////////////////////////////////////////////////////////////
	//更具指定的路径名打开文件,或者目录,可以通过制定文件的属性来决定找的是文
	//件还是目录，这里有一个问题，如果设置的查找的没有区分是文件还是目录的话，
	//程序会找到第一个字符串匹配的文件，之后的就不管了。此操作如果成功，那么
	//得到的文件对象需要Close来释放空间
	//param		
	//		path	文件路径,NUL结尾
	//		file	用于返回的我文件操作集合,需要先分配好缓存
	//		attr	要打开的NTFS文件属性  (ATTR_*),ATTR_NTFS_MASK表示所有的属性
	//				如果只是查找目录的话，建议 使用ATTR_DIRECTORY_INDEX和ATTR_DIRECTORY
	//				的组合,因为我感觉发现有些index区域的文件属性只有ATTR_DIRECTORY_INDEX，
	//return	操作结果
	//////////////////////////////////////////////////////////////////////////
	DRES OpenFileW(const WCHAR* path , DNtfsFile *file /*, DWORD attr = ATTR_NTFS_MASK*/);
	//DRES OpenFileA(const char* path , DNtfsFile *file /*, DWORD attr = ATTR_NTFS_MASK*/);

	//////////////////////////////////////////////////////////////////////////
	//初始化一个查找句柄,用于在指定的目录中查找文件,在调用这个方法成功之后需要
	//反复调用FindNext来获取每一文件获得目录,执行完毕之后需要调用CloseFind来关
	//闭查找句柄,否则内存泄露,
	//param	
	//			root	将要查找的目录路径
	//			hFind	用于返回查找句柄
	//			mftIndx	第一个找到的文件MFT记录
	//return	返回操作状态DR_INVALID_NAME表示路径失败
	//////////////////////////////////////////////////////////////////////////
	DRES FindFile(const WCHAR* root , FINDER* /*PFIND_FILE_HANDER*/ hFind /*,PLONG_INT mftIndx*/);
	DRES FindFile(const char* root , FINDER*  hFind);
	DRES FindFile(DNtfsFile* root , FINDER*  hFind);

	//////////////////////////////////////////////////////////////////////////
	//在指定的查找句柄汇总查找文件，
	//param	
	//			hFind	查找句柄
	//			mftIndx	返回找到的记录号
	//return	DR_FAT_EOF表示查找完了,DR_INVALID_HANDLE无效的查找句柄
	//////////////////////////////////////////////////////////////////////////
	DRES FindNext(/*PFIND_FILE_HANDER*/FINDER hFind ,PLONG_INT mftIndx);

	//////////////////////////////////////////////////////////////////////////
	//关闭查找句柄
	//////////////////////////////////////////////////////////////////////////
	void CloseFind(/*PFIND_FILE_HANDER*/FINDER hFind);

	//////////////////////////////////////////////////////////////////////////
	//获得每簇扇区数
	//////////////////////////////////////////////////////////////////////////
	BYTE GetSecPerClust();

	//////////////////////////////////////////////////////////////////////////
	//获得本卷的扇区总数
	//////////////////////////////////////////////////////////////////////////
	LONG_INT GetSecCount();

	//////////////////////////////////////////////////////////////////////////
	//获得当前逻辑驱动的卷名
	//param
	//		nameBuf		卷名缓存
	//		bufLen		卷名缓存的大小(字节)
	//return  返回操作状态,DR_NO_FILE_NAME表示没有找到卷名
	//////////////////////////////////////////////////////////////////////////
	DRES GetVolumeName(WCHAR * nameBuf , DWORD bufLen);

	//////////////////////////////////////////////////////////////////////////
	//判断指定设备的指定区域是否包含了NTFS相关标记
	//param	
	//		cDevName	设备的名字
	//		offset		指定区域在设备上的偏移
	//return	DR_OK	包含NTFS相关的标记
	//			DR_NO	没有包含NTFS标记
	//			其他	出错了
	//////////////////////////////////////////////////////////////////////////
	static DRES IsContainNTFSFlag(const WCHAR* cDevName, LONG_INT offset);

	//////////////////////////////////////////////////////////////////////////
	//获得设备的名字
	//return 设备名字
	//		如果设备没有打开的话返回NULL
	//////////////////////////////////////////////////////////////////////////
	const WCHAR* GetDevName();

	//////////////////////////////////////////////////////////////////////////
	//获得MFT的第一个VCN对应的LCN
	//return	MFT第一个簇号
	//			如果设备还没有打开的话返回0
	//////////////////////////////////////////////////////////////////////////
	LONG_INT GetClustForMFT();

	//////////////////////////////////////////////////////////////////////////
	//获得MFTMirr的第一个VCN对应的LCN
	//return	MFT第一个簇号
	//			如果设备还没有打开的话返回0
	//////////////////////////////////////////////////////////////////////////
	LONG_INT GetClustForMFTMirr();

	//////////////////////////////////////////////////////////////////////////
	//计算指定的mft记录所在的死一个扇区号
	//param
	//		mft	MFT记录号
	//return
	//		如果指定的MFT在使用的话则返回其第一扇区的扇区号
	//		如果指定的记录不存在的话则返回-1
	//////////////////////////////////////////////////////////////////////////
	LONG_INT GetSectorOfMFTRecode(LONG_INT mft);

};


#ifdef _UNICODE  //Unicode的接口

#define  OpenFile  OpenFileW

#else			//ASCII接口

#define  OpenFile  OpenFileA

#endif


//现在可以还原内存对齐方式了
#pragma pack(pop)

#endif
